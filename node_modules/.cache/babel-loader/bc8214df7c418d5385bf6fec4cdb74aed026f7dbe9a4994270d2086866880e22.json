{"ast":null,"code":"'use strict';\n\nmodule.exports = factory;\n\n// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.\nfunction factory(type) {\n  return tokenize;\n\n  // Tokenizer for a bound `type`.\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n\n    // Trim white space only lines.\n    if (!value) {\n      return tokens;\n    }\n\n    // Expose on `eat`.\n    eat.now = now;\n    eat.file = self.file;\n\n    // Sync initial offset.\n    updatePosition('');\n\n    // Iterate over `value`, and iterate over all tokenizers.  When one eats\n    // something, re-iterate with the remaining value.  If no tokenizer eats,\n    // something failed (should not happen) and an exception is thrown.\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        // Previously, we had constructs such as footnotes and YAML that used\n        // these properties.\n        // Those are now external (plus there are userland extensions), that may\n        // still use them.\n        if (method && ( /* istanbul ignore next */!method.onlyAtStart || self.atStart) && ( /* istanbul ignore next */!method.notInList || !self.inList) && ( /* istanbul ignore next */!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {\n          valueLength = value.length;\n          method.apply(self, [eat, value]);\n          matched = valueLength !== value.length;\n          if (matched) {\n            break;\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n    self.eof = now();\n    return tokens;\n\n    // Update line, column, and offset based on `value`.\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n\n    // Get offset.  Called before the first character is eaten to retrieve the\n    // range’s offsets.\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n\n      // Done.  Called when the last character is eaten to retrieve the range’s\n      // offsets.\n      return function () {\n        var last = line + 1;\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n          pos++;\n        }\n        return indentation;\n      };\n    }\n\n    // Get the current position.\n    function now() {\n      var pos = {\n        line: line,\n        column: column\n      };\n      pos.offset = self.toOffset(pos);\n      return pos;\n    }\n\n    // Store position information for a node.\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n\n    // Throw when a value is incorrectly eaten.  This shouldn’t happen but will\n    // throw on new, incorrect rules.\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.slice(0, subvalue.length) !== subvalue) {\n        // Capture stack-trace.\n        self.file.fail(new Error('Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'), now());\n      }\n    }\n\n    // Mark position and patch `node.position`.\n    function position() {\n      var before = now();\n      return update;\n\n      // Add the position to a node.\n      function update(node, indent) {\n        var previous = node.position;\n        var start = previous ? previous.start : before;\n        var combined = [];\n        var n = previous && previous.end.line;\n        var l = before.line;\n        node.position = new Position(start);\n\n        // If there was already a `position`, this node was merged.  Fixing\n        // `start` wasn’t hard, but the indent is different.  Especially\n        // because some information, the indent between `n` and `l` wasn’t\n        // tracked.  Luckily, that space is (should be?) empty, so we can\n        // safely check for it now.\n        if (previous && indent && previous.indent) {\n          combined = previous.indent;\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n            combined.push(before.column);\n          }\n          indent = combined.concat(indent);\n        }\n        node.position.indent = indent || [];\n        return node;\n      }\n    }\n\n    // Add `node` to `parent`s children or to `tokens`.  Performs merges where\n    // possible.\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var previous = children[children.length - 1];\n      var fn;\n      if (previous && node.type === previous.type && (node.type === 'text' || node.type === 'blockquote') && mergeable(previous) && mergeable(node)) {\n        fn = node.type === 'text' ? mergeText : mergeBlockquote;\n        node = fn.call(self, previous, node);\n      }\n      if (node !== previous) {\n        children.push(node);\n      }\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n      return node;\n    }\n\n    // Remove `subvalue` from `value`.  `subvalue` must be at the start of\n    // `value`.\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n      validateEat(subvalue);\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n      value = value.slice(subvalue.length);\n      updatePosition(subvalue);\n      indent = indent();\n      return apply;\n\n      // Add the given arguments, add `position` to the returned node, and\n      // return the node.\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n\n      // Functions just like apply, but resets the content: the line and\n      // column are reversed, and the eaten value is re-added.   This is\n      // useful for nodes with a single type of content, such as lists and\n      // tables.  See `apply` above for what parameters are expected.\n      function reset() {\n        var node = apply.apply(null, arguments);\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return node;\n      }\n\n      // Test the position, after eating, and reverse to a not-eaten state.\n      function test() {\n        var result = pos({});\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return result.position;\n      }\n    }\n  }\n}\n\n// Check whether a node is mergeable with adjacent nodes.\nfunction mergeable(node) {\n  var start;\n  var end;\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n  start = node.position.start;\n  end = node.position.end;\n\n  // Only merge nodes which occupy the same size as their `value`.\n  return start.line !== end.line || end.column - start.column === node.value.length;\n}\n\n// Merge two text nodes: `node` into `prev`.\nfunction mergeText(previous, node) {\n  previous.value += node.value;\n  return previous;\n}\n\n// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.\nfunction mergeBlockquote(previous, node) {\n  if (this.options.commonmark || this.options.gfm) {\n    return node;\n  }\n  previous.children = previous.children.concat(node.children);\n  return previous;\n}","map":{"version":3,"names":["module","exports","factory","type","tokenize","value","location","self","offset","tokens","methods","tokenizers","line","column","index","length","method","name","matched","valueLength","eat","now","file","updatePosition","onlyAtStart","atStart","notInList","inList","notInBlock","inBlock","notInLink","inLink","apply","fail","Error","eof","subvalue","lastIndex","indexOf","getOffset","indentation","pos","last","push","toOffset","Position","start","end","validateEat","slice","position","before","update","node","indent","previous","combined","n","l","concat","add","parent","children","fn","mergeable","mergeText","mergeBlockquote","call","exitStart","current","reset","test","arguments","result","options","commonmark","gfm"],"sources":["/home/kali/Desktop/react/React_Shopping_web/node_modules/remark-parse/lib/tokenizer.js"],"sourcesContent":["'use strict'\n\nmodule.exports = factory\n\n// Construct a tokenizer.  This creates both `tokenizeInline` and `tokenizeBlock`.\nfunction factory(type) {\n  return tokenize\n\n  // Tokenizer for a bound `type`.\n  function tokenize(value, location) {\n    var self = this\n    var offset = self.offset\n    var tokens = []\n    var methods = self[type + 'Methods']\n    var tokenizers = self[type + 'Tokenizers']\n    var line = location.line\n    var column = location.column\n    var index\n    var length\n    var method\n    var name\n    var matched\n    var valueLength\n\n    // Trim white space only lines.\n    if (!value) {\n      return tokens\n    }\n\n    // Expose on `eat`.\n    eat.now = now\n    eat.file = self.file\n\n    // Sync initial offset.\n    updatePosition('')\n\n    // Iterate over `value`, and iterate over all tokenizers.  When one eats\n    // something, re-iterate with the remaining value.  If no tokenizer eats,\n    // something failed (should not happen) and an exception is thrown.\n    while (value) {\n      index = -1\n      length = methods.length\n      matched = false\n\n      while (++index < length) {\n        name = methods[index]\n        method = tokenizers[name]\n\n        // Previously, we had constructs such as footnotes and YAML that used\n        // these properties.\n        // Those are now external (plus there are userland extensions), that may\n        // still use them.\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          /* istanbul ignore next */ (!method.notInList || !self.inList) &&\n          /* istanbul ignore next */ (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length\n\n          method.apply(self, [eat, value])\n\n          matched = valueLength !== value.length\n\n          if (matched) {\n            break\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now())\n      }\n    }\n\n    self.eof = now()\n\n    return tokens\n\n    // Update line, column, and offset based on `value`.\n    function updatePosition(subvalue) {\n      var lastIndex = -1\n      var index = subvalue.indexOf('\\n')\n\n      while (index !== -1) {\n        line++\n        lastIndex = index\n        index = subvalue.indexOf('\\n', index + 1)\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length\n      } else {\n        column = subvalue.length - lastIndex\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line]\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1\n        }\n      }\n    }\n\n    // Get offset.  Called before the first character is eaten to retrieve the\n    // range’s offsets.\n    function getOffset() {\n      var indentation = []\n      var pos = line + 1\n\n      // Done.  Called when the last character is eaten to retrieve the range’s\n      // offsets.\n      return function () {\n        var last = line + 1\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1)\n\n          pos++\n        }\n\n        return indentation\n      }\n    }\n\n    // Get the current position.\n    function now() {\n      var pos = {line: line, column: column}\n\n      pos.offset = self.toOffset(pos)\n\n      return pos\n    }\n\n    // Store position information for a node.\n    function Position(start) {\n      this.start = start\n      this.end = now()\n    }\n\n    // Throw when a value is incorrectly eaten.  This shouldn’t happen but will\n    // throw on new, incorrect rules.\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.slice(0, subvalue.length) !== subvalue) {\n        // Capture stack-trace.\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this warning on https://git.io/vg5Ft'\n          ),\n          now()\n        )\n      }\n    }\n\n    // Mark position and patch `node.position`.\n    function position() {\n      var before = now()\n\n      return update\n\n      // Add the position to a node.\n      function update(node, indent) {\n        var previous = node.position\n        var start = previous ? previous.start : before\n        var combined = []\n        var n = previous && previous.end.line\n        var l = before.line\n\n        node.position = new Position(start)\n\n        // If there was already a `position`, this node was merged.  Fixing\n        // `start` wasn’t hard, but the indent is different.  Especially\n        // because some information, the indent between `n` and `l` wasn’t\n        // tracked.  Luckily, that space is (should be?) empty, so we can\n        // safely check for it now.\n        if (previous && indent && previous.indent) {\n          combined = previous.indent\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1)\n            }\n\n            combined.push(before.column)\n          }\n\n          indent = combined.concat(indent)\n        }\n\n        node.position.indent = indent || []\n\n        return node\n      }\n    }\n\n    // Add `node` to `parent`s children or to `tokens`.  Performs merges where\n    // possible.\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens\n      var previous = children[children.length - 1]\n      var fn\n\n      if (\n        previous &&\n        node.type === previous.type &&\n        (node.type === 'text' || node.type === 'blockquote') &&\n        mergeable(previous) &&\n        mergeable(node)\n      ) {\n        fn = node.type === 'text' ? mergeText : mergeBlockquote\n        node = fn.call(self, previous, node)\n      }\n\n      if (node !== previous) {\n        children.push(node)\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart()\n      }\n\n      return node\n    }\n\n    // Remove `subvalue` from `value`.  `subvalue` must be at the start of\n    // `value`.\n    function eat(subvalue) {\n      var indent = getOffset()\n      var pos = position()\n      var current = now()\n\n      validateEat(subvalue)\n\n      apply.reset = reset\n      reset.test = test\n      apply.test = test\n\n      value = value.slice(subvalue.length)\n\n      updatePosition(subvalue)\n\n      indent = indent()\n\n      return apply\n\n      // Add the given arguments, add `position` to the returned node, and\n      // return the node.\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent)\n      }\n\n      // Functions just like apply, but resets the content: the line and\n      // column are reversed, and the eaten value is re-added.   This is\n      // useful for nodes with a single type of content, such as lists and\n      // tables.  See `apply` above for what parameters are expected.\n      function reset() {\n        var node = apply.apply(null, arguments)\n\n        line = current.line\n        column = current.column\n        value = subvalue + value\n\n        return node\n      }\n\n      // Test the position, after eating, and reverse to a not-eaten state.\n      function test() {\n        var result = pos({})\n\n        line = current.line\n        column = current.column\n        value = subvalue + value\n\n        return result.position\n      }\n    }\n  }\n}\n\n// Check whether a node is mergeable with adjacent nodes.\nfunction mergeable(node) {\n  var start\n  var end\n\n  if (node.type !== 'text' || !node.position) {\n    return true\n  }\n\n  start = node.position.start\n  end = node.position.end\n\n  // Only merge nodes which occupy the same size as their `value`.\n  return (\n    start.line !== end.line || end.column - start.column === node.value.length\n  )\n}\n\n// Merge two text nodes: `node` into `prev`.\nfunction mergeText(previous, node) {\n  previous.value += node.value\n\n  return previous\n}\n\n// Merge two blockquotes: `node` into `prev`, unless in CommonMark or gfm modes.\nfunction mergeBlockquote(previous, node) {\n  if (this.options.commonmark || this.options.gfm) {\n    return node\n  }\n\n  previous.children = previous.children.concat(node.children)\n\n  return previous\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}