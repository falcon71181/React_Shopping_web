{"ast":null,"code":"'use strict';\n\nmodule.exports = convert;\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n  if (test === null || test === undefined) {\n    return ok;\n  }\n  if (typeof test === 'object') {\n    return ('length' in test ? anyFactory : matchesFactory)(test);\n  }\n  if (typeof test === 'function') {\n    return test;\n  }\n  throw new Error('Expected function, string, or object as test');\n}\nfunction convertAll(tests) {\n  var results = [];\n  var length = tests.length;\n  var index = -1;\n  while (++index < length) {\n    results[index] = convert(tests[index]);\n  }\n  return results;\n}\n\n// Utility assert each property in `test` is represented in `node`, and each\n// values are strictly equal.\nfunction matchesFactory(test) {\n  return matches;\n  function matches(node) {\n    var key;\n    for (key in test) {\n      if (node[key] !== test[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nfunction anyFactory(tests) {\n  var checks = convertAll(tests);\n  var length = checks.length;\n  return matches;\n  function matches() {\n    var index = -1;\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n// Utility to convert a string into a function which checks a given node’s type\n// for said string.\nfunction typeFactory(test) {\n  return type;\n  function type(node) {\n    return Boolean(node && node.type === test);\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true;\n}","map":{"version":3,"names":["module","exports","convert","test","typeFactory","undefined","ok","anyFactory","matchesFactory","Error","convertAll","tests","results","length","index","matches","node","key","checks","apply","arguments","type","Boolean"],"sources":["/home/kali/Desktop/react/React_Shopping_web/node_modules/@mapbox/hast-util-table-cell-style/node_modules/unist-util-is/convert.js"],"sourcesContent":["'use strict'\n\nmodule.exports = convert\n\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return typeFactory(test)\n  }\n\n  if (test === null || test === undefined) {\n    return ok\n  }\n\n  if (typeof test === 'object') {\n    return ('length' in test ? anyFactory : matchesFactory)(test)\n  }\n\n  if (typeof test === 'function') {\n    return test\n  }\n\n  throw new Error('Expected function, string, or object as test')\n}\n\nfunction convertAll(tests) {\n  var results = []\n  var length = tests.length\n  var index = -1\n\n  while (++index < length) {\n    results[index] = convert(tests[index])\n  }\n\n  return results\n}\n\n// Utility assert each property in `test` is represented in `node`, and each\n// values are strictly equal.\nfunction matchesFactory(test) {\n  return matches\n\n  function matches(node) {\n    var key\n\n    for (key in test) {\n      if (node[key] !== test[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = convertAll(tests)\n  var length = checks.length\n\n  return matches\n\n  function matches() {\n    var index = -1\n\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n// Utility to convert a string into a function which checks a given node’s type\n// for said string.\nfunction typeFactory(test) {\n  return type\n\n  function type(node) {\n    return Boolean(node && node.type === test)\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true\n}\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAGC,OAAO;AAExB,SAASA,OAAOA,CAACC,IAAI,EAAE;EACrB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAOC,WAAW,CAACD,IAAI,CAAC;EAC1B;EAEA,IAAIA,IAAI,KAAK,IAAI,IAAIA,IAAI,KAAKE,SAAS,EAAE;IACvC,OAAOC,EAAE;EACX;EAEA,IAAI,OAAOH,IAAI,KAAK,QAAQ,EAAE;IAC5B,OAAO,CAAC,QAAQ,IAAIA,IAAI,GAAGI,UAAU,GAAGC,cAAc,EAAEL,IAAI,CAAC;EAC/D;EAEA,IAAI,OAAOA,IAAI,KAAK,UAAU,EAAE;IAC9B,OAAOA,IAAI;EACb;EAEA,MAAM,IAAIM,KAAK,CAAC,8CAA8C,CAAC;AACjE;AAEA,SAASC,UAAUA,CAACC,KAAK,EAAE;EACzB,IAAIC,OAAO,GAAG,EAAE;EAChB,IAAIC,MAAM,GAAGF,KAAK,CAACE,MAAM;EACzB,IAAIC,KAAK,GAAG,CAAC,CAAC;EAEd,OAAO,EAAEA,KAAK,GAAGD,MAAM,EAAE;IACvBD,OAAO,CAACE,KAAK,CAAC,GAAGZ,OAAO,CAACS,KAAK,CAACG,KAAK,CAAC,CAAC;EACxC;EAEA,OAAOF,OAAO;AAChB;;AAEA;AACA;AACA,SAASJ,cAAcA,CAACL,IAAI,EAAE;EAC5B,OAAOY,OAAO;EAEd,SAASA,OAAOA,CAACC,IAAI,EAAE;IACrB,IAAIC,GAAG;IAEP,KAAKA,GAAG,IAAId,IAAI,EAAE;MAChB,IAAIa,IAAI,CAACC,GAAG,CAAC,KAAKd,IAAI,CAACc,GAAG,CAAC,EAAE;QAC3B,OAAO,KAAK;MACd;IACF;IAEA,OAAO,IAAI;EACb;AACF;AAEA,SAASV,UAAUA,CAACI,KAAK,EAAE;EACzB,IAAIO,MAAM,GAAGR,UAAU,CAACC,KAAK,CAAC;EAC9B,IAAIE,MAAM,GAAGK,MAAM,CAACL,MAAM;EAE1B,OAAOE,OAAO;EAEd,SAASA,OAAOA,CAAA,EAAG;IACjB,IAAID,KAAK,GAAG,CAAC,CAAC;IAEd,OAAO,EAAEA,KAAK,GAAGD,MAAM,EAAE;MACvB,IAAIK,MAAM,CAACJ,KAAK,CAAC,CAACK,KAAK,CAAC,IAAI,EAAEC,SAAS,CAAC,EAAE;QACxC,OAAO,IAAI;MACb;IACF;IAEA,OAAO,KAAK;EACd;AACF;;AAEA;AACA;AACA,SAAShB,WAAWA,CAACD,IAAI,EAAE;EACzB,OAAOkB,IAAI;EAEX,SAASA,IAAIA,CAACL,IAAI,EAAE;IAClB,OAAOM,OAAO,CAACN,IAAI,IAAIA,IAAI,CAACK,IAAI,KAAKlB,IAAI,CAAC;EAC5C;AACF;;AAEA;AACA,SAASG,EAAEA,CAAA,EAAG;EACZ,OAAO,IAAI;AACb"},"metadata":{},"sourceType":"script","externalDependencies":[]}