{"ast":null,"code":"'use strict';\n\nmodule.exports = fencedCode;\nvar lineFeed = '\\n';\nvar tab = '\\t';\nvar space = ' ';\nvar tilde = '~';\nvar graveAccent = '`';\nvar minFenceCount = 3;\nvar tabSize = 4;\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var gfm = self.options.gfm;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var lang;\n  var meta;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n  if (!gfm) {\n    return;\n  }\n\n  // Eat initial spacing.\n  while (index < length) {\n    character = value.charAt(index);\n    if (character !== space && character !== tab) {\n      break;\n    }\n    subvalue += character;\n    index++;\n  }\n  indent = index;\n\n  // Eat the fence.\n  character = value.charAt(index);\n  if (character !== tilde && character !== graveAccent) {\n    return;\n  }\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n  while (index < length) {\n    character = value.charAt(index);\n    if (character !== marker) {\n      break;\n    }\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n  if (fenceCount < minFenceCount) {\n    return;\n  }\n\n  // Eat spacing before flag.\n  while (index < length) {\n    character = value.charAt(index);\n    if (character !== space && character !== tab) {\n      break;\n    }\n    subvalue += character;\n    index++;\n  }\n\n  // Eat flag.\n  flag = '';\n  queue = '';\n  while (index < length) {\n    character = value.charAt(index);\n    if (character === lineFeed || marker === graveAccent && character === marker) {\n      break;\n    }\n    if (character === space || character === tab) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n    index++;\n  }\n  character = value.charAt(index);\n  if (character && character !== lineFeed) {\n    return;\n  }\n  if (silent) {\n    return true;\n  }\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n  if (queue) {\n    subvalue += queue;\n  }\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n  var skip = true;\n\n  // Eat content.\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n    if (character !== lineFeed) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n\n    // The first line feed is ignored. Others aren’t.\n    if (skip) {\n      subvalue += character;\n      skip = false;\n    } else {\n      closing += character;\n      exdentedClosing += character;\n    }\n    queue = '';\n    index++;\n    while (index < length) {\n      character = value.charAt(index);\n      if (character !== space) {\n        break;\n      }\n      queue += character;\n      index++;\n    }\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n    if (queue.length >= tabSize) {\n      continue;\n    }\n    queue = '';\n    while (index < length) {\n      character = value.charAt(index);\n      if (character !== marker) {\n        break;\n      }\n      queue += character;\n      index++;\n    }\n    closing += queue;\n    exdentedClosing += queue;\n    if (queue.length < fenceCount) {\n      continue;\n    }\n    queue = '';\n    while (index < length) {\n      character = value.charAt(index);\n      if (character !== space && character !== tab) {\n        break;\n      }\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n    if (!character || character === lineFeed) {\n      break;\n    }\n  }\n  subvalue += content + closing;\n\n  // Get lang and meta from the flag.\n  index = -1;\n  length = flag.length;\n  while (++index < length) {\n    character = flag.charAt(index);\n    if (character === space || character === tab) {\n      if (!lang) {\n        lang = flag.slice(0, index);\n      }\n    } else if (lang) {\n      meta = flag.slice(index);\n      break;\n    }\n  }\n  return eat(subvalue)({\n    type: 'code',\n    lang: lang || flag || null,\n    meta: meta || null,\n    value: exdentedContent\n  });\n}","map":{"version":3,"names":["module","exports","fencedCode","lineFeed","tab","space","tilde","graveAccent","minFenceCount","tabSize","eat","value","silent","self","gfm","options","length","index","subvalue","fenceCount","marker","character","flag","lang","meta","queue","content","exdentedContent","closing","exdentedClosing","indent","now","charAt","column","offset","decode","raw","unescape","skip","slice","type"],"sources":["/home/kali/Desktop/react/React_Shopping_web/node_modules/remark-parse/lib/tokenize/code-fenced.js"],"sourcesContent":["'use strict'\n\nmodule.exports = fencedCode\n\nvar lineFeed = '\\n'\nvar tab = '\\t'\nvar space = ' '\nvar tilde = '~'\nvar graveAccent = '`'\n\nvar minFenceCount = 3\nvar tabSize = 4\n\nfunction fencedCode(eat, value, silent) {\n  var self = this\n  var gfm = self.options.gfm\n  var length = value.length + 1\n  var index = 0\n  var subvalue = ''\n  var fenceCount\n  var marker\n  var character\n  var flag\n  var lang\n  var meta\n  var queue\n  var content\n  var exdentedContent\n  var closing\n  var exdentedClosing\n  var indent\n  var now\n\n  if (!gfm) {\n    return\n  }\n\n  // Eat initial spacing.\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  indent = index\n\n  // Eat the fence.\n  character = value.charAt(index)\n\n  if (character !== tilde && character !== graveAccent) {\n    return\n  }\n\n  index++\n  marker = character\n  fenceCount = 1\n  subvalue += character\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== marker) {\n      break\n    }\n\n    subvalue += character\n    fenceCount++\n    index++\n  }\n\n  if (fenceCount < minFenceCount) {\n    return\n  }\n\n  // Eat spacing before flag.\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character !== space && character !== tab) {\n      break\n    }\n\n    subvalue += character\n    index++\n  }\n\n  // Eat flag.\n  flag = ''\n  queue = ''\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (\n      character === lineFeed ||\n      (marker === graveAccent && character === marker)\n    ) {\n      break\n    }\n\n    if (character === space || character === tab) {\n      queue += character\n    } else {\n      flag += queue + character\n      queue = ''\n    }\n\n    index++\n  }\n\n  character = value.charAt(index)\n\n  if (character && character !== lineFeed) {\n    return\n  }\n\n  if (silent) {\n    return true\n  }\n\n  now = eat.now()\n  now.column += subvalue.length\n  now.offset += subvalue.length\n\n  subvalue += flag\n  flag = self.decode.raw(self.unescape(flag), now)\n\n  if (queue) {\n    subvalue += queue\n  }\n\n  queue = ''\n  closing = ''\n  exdentedClosing = ''\n  content = ''\n  exdentedContent = ''\n  var skip = true\n\n  // Eat content.\n  while (index < length) {\n    character = value.charAt(index)\n    content += closing\n    exdentedContent += exdentedClosing\n    closing = ''\n    exdentedClosing = ''\n\n    if (character !== lineFeed) {\n      content += character\n      exdentedClosing += character\n      index++\n      continue\n    }\n\n    // The first line feed is ignored. Others aren’t.\n    if (skip) {\n      subvalue += character\n      skip = false\n    } else {\n      closing += character\n      exdentedClosing += character\n    }\n\n    queue = ''\n    index++\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== space) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    closing += queue\n    exdentedClosing += queue.slice(indent)\n\n    if (queue.length >= tabSize) {\n      continue\n    }\n\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== marker) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n\n    closing += queue\n    exdentedClosing += queue\n\n    if (queue.length < fenceCount) {\n      continue\n    }\n\n    queue = ''\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character !== space && character !== tab) {\n        break\n      }\n\n      closing += character\n      exdentedClosing += character\n      index++\n    }\n\n    if (!character || character === lineFeed) {\n      break\n    }\n  }\n\n  subvalue += content + closing\n\n  // Get lang and meta from the flag.\n  index = -1\n  length = flag.length\n\n  while (++index < length) {\n    character = flag.charAt(index)\n\n    if (character === space || character === tab) {\n      if (!lang) {\n        lang = flag.slice(0, index)\n      }\n    } else if (lang) {\n      meta = flag.slice(index)\n      break\n    }\n  }\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: lang || flag || null,\n    meta: meta || null,\n    value: exdentedContent\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}