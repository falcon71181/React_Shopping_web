{"ast":null,"code":"'use strict';\n\nvar trim = require('trim');\nvar trimTrailingLines = require('trim-trailing-lines');\nvar interrupt = require('../util/interrupt');\nmodule.exports = paragraph;\nvar tab = '\\t';\nvar lineFeed = '\\n';\nvar space = ' ';\nvar tabSize = 4;\n\n// Tokenise paragraph.\nfunction paragraph(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var commonmark = settings.commonmark;\n  var tokenizers = self.blockTokenizers;\n  var interruptors = self.interruptParagraph;\n  var index = value.indexOf(lineFeed);\n  var length = value.length;\n  var position;\n  var subvalue;\n  var character;\n  var size;\n  var now;\n  while (index < length) {\n    // Eat everything if there’s no following newline.\n    if (index === -1) {\n      index = length;\n      break;\n    }\n\n    // Stop if the next character is NEWLINE.\n    if (value.charAt(index + 1) === lineFeed) {\n      break;\n    }\n\n    // In commonmark-mode, following indented lines are part of the paragraph.\n    if (commonmark) {\n      size = 0;\n      position = index + 1;\n      while (position < length) {\n        character = value.charAt(position);\n        if (character === tab) {\n          size = tabSize;\n          break;\n        } else if (character === space) {\n          size++;\n        } else {\n          break;\n        }\n        position++;\n      }\n      if (size >= tabSize && character !== lineFeed) {\n        index = value.indexOf(lineFeed, index + 1);\n        continue;\n      }\n    }\n    subvalue = value.slice(index + 1);\n\n    // Check if the following code contains a possible block.\n    if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {\n      break;\n    }\n    position = index;\n    index = value.indexOf(lineFeed, index + 1);\n    if (index !== -1 && trim(value.slice(position, index)) === '') {\n      index = position;\n      break;\n    }\n  }\n  subvalue = value.slice(0, index);\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n  now = eat.now();\n  subvalue = trimTrailingLines(subvalue);\n  return eat(subvalue)({\n    type: 'paragraph',\n    children: self.tokenizeInline(subvalue, now)\n  });\n}","map":{"version":3,"names":["trim","require","trimTrailingLines","interrupt","module","exports","paragraph","tab","lineFeed","space","tabSize","eat","value","silent","self","settings","options","commonmark","tokenizers","blockTokenizers","interruptors","interruptParagraph","index","indexOf","length","position","subvalue","character","size","now","charAt","slice","type","children","tokenizeInline"],"sources":["/home/kali/Desktop/react/React_Shopping_web/node_modules/remark-parse/lib/tokenize/paragraph.js"],"sourcesContent":["'use strict'\n\nvar trim = require('trim')\nvar trimTrailingLines = require('trim-trailing-lines')\nvar interrupt = require('../util/interrupt')\n\nmodule.exports = paragraph\n\nvar tab = '\\t'\nvar lineFeed = '\\n'\nvar space = ' '\n\nvar tabSize = 4\n\n// Tokenise paragraph.\nfunction paragraph(eat, value, silent) {\n  var self = this\n  var settings = self.options\n  var commonmark = settings.commonmark\n  var tokenizers = self.blockTokenizers\n  var interruptors = self.interruptParagraph\n  var index = value.indexOf(lineFeed)\n  var length = value.length\n  var position\n  var subvalue\n  var character\n  var size\n  var now\n\n  while (index < length) {\n    // Eat everything if there’s no following newline.\n    if (index === -1) {\n      index = length\n      break\n    }\n\n    // Stop if the next character is NEWLINE.\n    if (value.charAt(index + 1) === lineFeed) {\n      break\n    }\n\n    // In commonmark-mode, following indented lines are part of the paragraph.\n    if (commonmark) {\n      size = 0\n      position = index + 1\n\n      while (position < length) {\n        character = value.charAt(position)\n\n        if (character === tab) {\n          size = tabSize\n          break\n        } else if (character === space) {\n          size++\n        } else {\n          break\n        }\n\n        position++\n      }\n\n      if (size >= tabSize && character !== lineFeed) {\n        index = value.indexOf(lineFeed, index + 1)\n        continue\n      }\n    }\n\n    subvalue = value.slice(index + 1)\n\n    // Check if the following code contains a possible block.\n    if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {\n      break\n    }\n\n    position = index\n    index = value.indexOf(lineFeed, index + 1)\n\n    if (index !== -1 && trim(value.slice(position, index)) === '') {\n      index = position\n      break\n    }\n  }\n\n  subvalue = value.slice(0, index)\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  now = eat.now()\n  subvalue = trimTrailingLines(subvalue)\n\n  return eat(subvalue)({\n    type: 'paragraph',\n    children: self.tokenizeInline(subvalue, now)\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}