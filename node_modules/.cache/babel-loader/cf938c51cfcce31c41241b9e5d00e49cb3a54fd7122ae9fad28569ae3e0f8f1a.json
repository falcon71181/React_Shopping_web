{"ast":null,"code":"'use strict';\n\nvar ccount = require('ccount');\nvar decode = require('parse-entities');\nvar decimal = require('is-decimal');\nvar alphabetical = require('is-alphabetical');\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/url');\nmodule.exports = url;\nurl.locator = locate;\nurl.notInLink = true;\nvar exclamationMark = 33; // '!'\nvar ampersand = 38; // '&'\nvar rightParenthesis = 41; // ')'\nvar asterisk = 42; // '*'\nvar comma = 44; // ','\nvar dash = 45; // '-'\nvar dot = 46; // '.'\nvar colon = 58; // ':'\nvar semicolon = 59; // ';'\nvar questionMark = 63; // '?'\nvar lessThan = 60; // '<'\nvar underscore = 95; // '_'\nvar tilde = 126; // '~'\n\nvar leftParenthesisCharacter = '(';\nvar rightParenthesisCharacter = ')';\nfunction url(eat, value, silent) {\n  var self = this;\n  var gfm = self.options.gfm;\n  var tokenizers = self.inlineTokenizers;\n  var length = value.length;\n  var previousDot = -1;\n  var protocolless = false;\n  var dots;\n  var lastTwoPartsStart;\n  var start;\n  var index;\n  var pathStart;\n  var path;\n  var code;\n  var end;\n  var leftCount;\n  var rightCount;\n  var content;\n  var children;\n  var url;\n  var exit;\n  if (!gfm) {\n    return;\n  }\n\n  // `WWW.` doesn’t work.\n  if (value.slice(0, 4) === 'www.') {\n    protocolless = true;\n    index = 4;\n  } else if (value.slice(0, 7).toLowerCase() === 'http://') {\n    index = 7;\n  } else if (value.slice(0, 8).toLowerCase() === 'https://') {\n    index = 8;\n  } else {\n    return;\n  }\n\n  // Act as if the starting boundary is a dot.\n  previousDot = index - 1;\n\n  // Parse a valid domain.\n  start = index;\n  dots = [];\n  while (index < length) {\n    code = value.charCodeAt(index);\n    if (code === dot) {\n      // Dots may not appear after each other.\n      if (previousDot === index - 1) {\n        break;\n      }\n      dots.push(index);\n      previousDot = index;\n      index++;\n      continue;\n    }\n    if (decimal(code) || alphabetical(code) || code === dash || code === underscore) {\n      index++;\n      continue;\n    }\n    break;\n  }\n\n  // Ignore a final dot:\n  if (code === dot) {\n    dots.pop();\n    index--;\n  }\n\n  // If there are not dots, exit.\n  if (dots[0] === undefined) {\n    return;\n  }\n\n  // If there is an underscore in the last two domain parts, exit:\n  // `www.example.c_m` and `www.ex_ample.com` are not OK, but\n  // `www.sub_domain.example.com` is.\n  lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1;\n  if (value.slice(lastTwoPartsStart, index).indexOf('_') !== -1) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n  end = index;\n  pathStart = index;\n\n  // Parse a path.\n  while (index < length) {\n    code = value.charCodeAt(index);\n    if (whitespace(code) || code === lessThan) {\n      break;\n    }\n    index++;\n    if (code === exclamationMark || code === asterisk || code === comma || code === dot || code === colon || code === questionMark || code === underscore || code === tilde) {\n      // Empty\n    } else {\n      end = index;\n    }\n  }\n  index = end;\n\n  // If the path ends in a closing paren, and the count of closing parens is\n  // higher than the opening count, then remove the supefluous closing parens.\n  if (value.charCodeAt(index - 1) === rightParenthesis) {\n    path = value.slice(pathStart, index);\n    leftCount = ccount(path, leftParenthesisCharacter);\n    rightCount = ccount(path, rightParenthesisCharacter);\n    while (rightCount > leftCount) {\n      index = pathStart + path.lastIndexOf(rightParenthesisCharacter);\n      path = value.slice(pathStart, index);\n      rightCount--;\n    }\n  }\n  if (value.charCodeAt(index - 1) === semicolon) {\n    // GitHub doesn’t document this, but final semicolons aren’t paret of the\n    // URL either.\n    index--;\n\n    // // If the path ends in what looks like an entity, it’s not part of the path.\n    if (alphabetical(value.charCodeAt(index - 1))) {\n      end = index - 2;\n      while (alphabetical(value.charCodeAt(end))) {\n        end--;\n      }\n      if (value.charCodeAt(end) === ampersand) {\n        index = end;\n      }\n    }\n  }\n  content = value.slice(0, index);\n  url = decode(content, {\n    nonTerminated: false\n  });\n  if (protocolless) {\n    url = 'http://' + url;\n  }\n  exit = self.enterLink();\n\n  // Temporarily remove all tokenizers except text in url.\n  self.inlineTokenizers = {\n    text: tokenizers.text\n  };\n  children = self.tokenizeInline(content, eat.now());\n  self.inlineTokenizers = tokenizers;\n  exit();\n  return eat(content)({\n    type: 'link',\n    title: null,\n    url: url,\n    children: children\n  });\n}","map":{"version":3,"names":["ccount","require","decode","decimal","alphabetical","whitespace","locate","module","exports","url","locator","notInLink","exclamationMark","ampersand","rightParenthesis","asterisk","comma","dash","dot","colon","semicolon","questionMark","lessThan","underscore","tilde","leftParenthesisCharacter","rightParenthesisCharacter","eat","value","silent","self","gfm","options","tokenizers","inlineTokenizers","length","previousDot","protocolless","dots","lastTwoPartsStart","start","index","pathStart","path","code","end","leftCount","rightCount","content","children","exit","slice","toLowerCase","charCodeAt","push","pop","undefined","indexOf","lastIndexOf","nonTerminated","enterLink","text","tokenizeInline","now","type","title"],"sources":["/home/kali/Desktop/react/React_Shopping_web/node_modules/remark-parse/lib/tokenize/url.js"],"sourcesContent":["'use strict'\n\nvar ccount = require('ccount')\nvar decode = require('parse-entities')\nvar decimal = require('is-decimal')\nvar alphabetical = require('is-alphabetical')\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/url')\n\nmodule.exports = url\nurl.locator = locate\nurl.notInLink = true\n\nvar exclamationMark = 33 // '!'\nvar ampersand = 38 // '&'\nvar rightParenthesis = 41 // ')'\nvar asterisk = 42 // '*'\nvar comma = 44 // ','\nvar dash = 45 // '-'\nvar dot = 46 // '.'\nvar colon = 58 // ':'\nvar semicolon = 59 // ';'\nvar questionMark = 63 // '?'\nvar lessThan = 60 // '<'\nvar underscore = 95 // '_'\nvar tilde = 126 // '~'\n\nvar leftParenthesisCharacter = '('\nvar rightParenthesisCharacter = ')'\n\nfunction url(eat, value, silent) {\n  var self = this\n  var gfm = self.options.gfm\n  var tokenizers = self.inlineTokenizers\n  var length = value.length\n  var previousDot = -1\n  var protocolless = false\n  var dots\n  var lastTwoPartsStart\n  var start\n  var index\n  var pathStart\n  var path\n  var code\n  var end\n  var leftCount\n  var rightCount\n  var content\n  var children\n  var url\n  var exit\n\n  if (!gfm) {\n    return\n  }\n\n  // `WWW.` doesn’t work.\n  if (value.slice(0, 4) === 'www.') {\n    protocolless = true\n    index = 4\n  } else if (value.slice(0, 7).toLowerCase() === 'http://') {\n    index = 7\n  } else if (value.slice(0, 8).toLowerCase() === 'https://') {\n    index = 8\n  } else {\n    return\n  }\n\n  // Act as if the starting boundary is a dot.\n  previousDot = index - 1\n\n  // Parse a valid domain.\n  start = index\n  dots = []\n\n  while (index < length) {\n    code = value.charCodeAt(index)\n\n    if (code === dot) {\n      // Dots may not appear after each other.\n      if (previousDot === index - 1) {\n        break\n      }\n\n      dots.push(index)\n      previousDot = index\n      index++\n      continue\n    }\n\n    if (\n      decimal(code) ||\n      alphabetical(code) ||\n      code === dash ||\n      code === underscore\n    ) {\n      index++\n      continue\n    }\n\n    break\n  }\n\n  // Ignore a final dot:\n  if (code === dot) {\n    dots.pop()\n    index--\n  }\n\n  // If there are not dots, exit.\n  if (dots[0] === undefined) {\n    return\n  }\n\n  // If there is an underscore in the last two domain parts, exit:\n  // `www.example.c_m` and `www.ex_ample.com` are not OK, but\n  // `www.sub_domain.example.com` is.\n  lastTwoPartsStart = dots.length < 2 ? start : dots[dots.length - 2] + 1\n\n  if (value.slice(lastTwoPartsStart, index).indexOf('_') !== -1) {\n    return\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  end = index\n  pathStart = index\n\n  // Parse a path.\n  while (index < length) {\n    code = value.charCodeAt(index)\n\n    if (whitespace(code) || code === lessThan) {\n      break\n    }\n\n    index++\n\n    if (\n      code === exclamationMark ||\n      code === asterisk ||\n      code === comma ||\n      code === dot ||\n      code === colon ||\n      code === questionMark ||\n      code === underscore ||\n      code === tilde\n    ) {\n      // Empty\n    } else {\n      end = index\n    }\n  }\n\n  index = end\n\n  // If the path ends in a closing paren, and the count of closing parens is\n  // higher than the opening count, then remove the supefluous closing parens.\n  if (value.charCodeAt(index - 1) === rightParenthesis) {\n    path = value.slice(pathStart, index)\n    leftCount = ccount(path, leftParenthesisCharacter)\n    rightCount = ccount(path, rightParenthesisCharacter)\n\n    while (rightCount > leftCount) {\n      index = pathStart + path.lastIndexOf(rightParenthesisCharacter)\n      path = value.slice(pathStart, index)\n      rightCount--\n    }\n  }\n\n  if (value.charCodeAt(index - 1) === semicolon) {\n    // GitHub doesn’t document this, but final semicolons aren’t paret of the\n    // URL either.\n    index--\n\n    // // If the path ends in what looks like an entity, it’s not part of the path.\n    if (alphabetical(value.charCodeAt(index - 1))) {\n      end = index - 2\n\n      while (alphabetical(value.charCodeAt(end))) {\n        end--\n      }\n\n      if (value.charCodeAt(end) === ampersand) {\n        index = end\n      }\n    }\n  }\n\n  content = value.slice(0, index)\n  url = decode(content, {nonTerminated: false})\n\n  if (protocolless) {\n    url = 'http://' + url\n  }\n\n  exit = self.enterLink()\n\n  // Temporarily remove all tokenizers except text in url.\n  self.inlineTokenizers = {text: tokenizers.text}\n  children = self.tokenizeInline(content, eat.now())\n  self.inlineTokenizers = tokenizers\n\n  exit()\n\n  return eat(content)({type: 'link', title: null, url: url, children: children})\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}