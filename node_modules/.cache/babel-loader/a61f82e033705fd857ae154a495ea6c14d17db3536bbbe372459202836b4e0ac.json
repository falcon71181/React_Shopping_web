{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/link');\nvar normalize = require('../util/normalize');\nmodule.exports = reference;\nreference.locator = locate;\nvar link = 'link';\nvar image = 'image';\nvar shortcut = 'shortcut';\nvar collapsed = 'collapsed';\nvar full = 'full';\nvar exclamationMark = '!';\nvar leftSquareBracket = '[';\nvar backslash = '\\\\';\nvar rightSquareBracket = ']';\nfunction reference(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var character = value.charAt(0);\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var intro = '';\n  var type = link;\n  var referenceType = shortcut;\n  var content;\n  var identifier;\n  var now;\n  var node;\n  var exit;\n  var queue;\n  var bracketed;\n  var depth;\n\n  // Check whether we’re eating an image.\n  if (character === exclamationMark) {\n    type = image;\n    intro = character;\n    character = value.charAt(++index);\n  }\n  if (character !== leftSquareBracket) {\n    return;\n  }\n  index++;\n  intro += character;\n  queue = '';\n\n  // Eat the text.\n  depth = 0;\n  while (index < length) {\n    character = value.charAt(index);\n    if (character === leftSquareBracket) {\n      bracketed = true;\n      depth++;\n    } else if (character === rightSquareBracket) {\n      if (!depth) {\n        break;\n      }\n      depth--;\n    }\n    if (character === backslash) {\n      queue += backslash;\n      character = value.charAt(++index);\n    }\n    queue += character;\n    index++;\n  }\n  subvalue = queue;\n  content = queue;\n  character = value.charAt(index);\n  if (character !== rightSquareBracket) {\n    return;\n  }\n  index++;\n  subvalue += character;\n  queue = '';\n  if (!commonmark) {\n    // The original markdown syntax definition explicitly allows for whitespace\n    // between the link text and link label; commonmark departs from this, in\n    // part to improve support for shortcut reference links\n    while (index < length) {\n      character = value.charAt(index);\n      if (!whitespace(character)) {\n        break;\n      }\n      queue += character;\n      index++;\n    }\n  }\n  character = value.charAt(index);\n  if (character === leftSquareBracket) {\n    identifier = '';\n    queue += character;\n    index++;\n    while (index < length) {\n      character = value.charAt(index);\n      if (character === leftSquareBracket || character === rightSquareBracket) {\n        break;\n      }\n      if (character === backslash) {\n        identifier += backslash;\n        character = value.charAt(++index);\n      }\n      identifier += character;\n      index++;\n    }\n    character = value.charAt(index);\n    if (character === rightSquareBracket) {\n      referenceType = identifier ? full : collapsed;\n      queue += identifier + character;\n      index++;\n    } else {\n      identifier = '';\n    }\n    subvalue += queue;\n    queue = '';\n  } else {\n    if (!content) {\n      return;\n    }\n    identifier = content;\n  }\n\n  // Brackets cannot be inside the identifier.\n  if (referenceType !== full && bracketed) {\n    return;\n  }\n  subvalue = intro + subvalue;\n  if (type === link && self.inLink) {\n    return null;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n  now = eat.now();\n  now.column += intro.length;\n  now.offset += intro.length;\n  identifier = referenceType === full ? identifier : content;\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier),\n    label: identifier,\n    referenceType: referenceType\n  };\n  if (type === link) {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  } else {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  }\n  return eat(subvalue)(node);\n}","map":{"version":3,"names":["whitespace","require","locate","normalize","module","exports","reference","locator","link","image","shortcut","collapsed","full","exclamationMark","leftSquareBracket","backslash","rightSquareBracket","eat","value","silent","self","commonmark","options","character","charAt","index","length","subvalue","intro","type","referenceType","content","identifier","now","node","exit","queue","bracketed","depth","inLink","column","offset","label","enterLink","children","tokenizeInline","alt","decode","raw","unescape"],"sources":["/home/kali/Desktop/react/React_Shopping_web/node_modules/remark-parse/lib/tokenize/reference.js"],"sourcesContent":["'use strict'\n\nvar whitespace = require('is-whitespace-character')\nvar locate = require('../locate/link')\nvar normalize = require('../util/normalize')\n\nmodule.exports = reference\nreference.locator = locate\n\nvar link = 'link'\nvar image = 'image'\nvar shortcut = 'shortcut'\nvar collapsed = 'collapsed'\nvar full = 'full'\nvar exclamationMark = '!'\nvar leftSquareBracket = '['\nvar backslash = '\\\\'\nvar rightSquareBracket = ']'\n\nfunction reference(eat, value, silent) {\n  var self = this\n  var commonmark = self.options.commonmark\n  var character = value.charAt(0)\n  var index = 0\n  var length = value.length\n  var subvalue = ''\n  var intro = ''\n  var type = link\n  var referenceType = shortcut\n  var content\n  var identifier\n  var now\n  var node\n  var exit\n  var queue\n  var bracketed\n  var depth\n\n  // Check whether we’re eating an image.\n  if (character === exclamationMark) {\n    type = image\n    intro = character\n    character = value.charAt(++index)\n  }\n\n  if (character !== leftSquareBracket) {\n    return\n  }\n\n  index++\n  intro += character\n  queue = ''\n\n  // Eat the text.\n  depth = 0\n\n  while (index < length) {\n    character = value.charAt(index)\n\n    if (character === leftSquareBracket) {\n      bracketed = true\n      depth++\n    } else if (character === rightSquareBracket) {\n      if (!depth) {\n        break\n      }\n\n      depth--\n    }\n\n    if (character === backslash) {\n      queue += backslash\n      character = value.charAt(++index)\n    }\n\n    queue += character\n    index++\n  }\n\n  subvalue = queue\n  content = queue\n  character = value.charAt(index)\n\n  if (character !== rightSquareBracket) {\n    return\n  }\n\n  index++\n  subvalue += character\n  queue = ''\n\n  if (!commonmark) {\n    // The original markdown syntax definition explicitly allows for whitespace\n    // between the link text and link label; commonmark departs from this, in\n    // part to improve support for shortcut reference links\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (!whitespace(character)) {\n        break\n      }\n\n      queue += character\n      index++\n    }\n  }\n\n  character = value.charAt(index)\n\n  if (character === leftSquareBracket) {\n    identifier = ''\n    queue += character\n    index++\n\n    while (index < length) {\n      character = value.charAt(index)\n\n      if (character === leftSquareBracket || character === rightSquareBracket) {\n        break\n      }\n\n      if (character === backslash) {\n        identifier += backslash\n        character = value.charAt(++index)\n      }\n\n      identifier += character\n      index++\n    }\n\n    character = value.charAt(index)\n\n    if (character === rightSquareBracket) {\n      referenceType = identifier ? full : collapsed\n      queue += identifier + character\n      index++\n    } else {\n      identifier = ''\n    }\n\n    subvalue += queue\n    queue = ''\n  } else {\n    if (!content) {\n      return\n    }\n\n    identifier = content\n  }\n\n  // Brackets cannot be inside the identifier.\n  if (referenceType !== full && bracketed) {\n    return\n  }\n\n  subvalue = intro + subvalue\n\n  if (type === link && self.inLink) {\n    return null\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true\n  }\n\n  now = eat.now()\n  now.column += intro.length\n  now.offset += intro.length\n  identifier = referenceType === full ? identifier : content\n\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier),\n    label: identifier,\n    referenceType: referenceType\n  }\n\n  if (type === link) {\n    exit = self.enterLink()\n    node.children = self.tokenizeInline(content, now)\n    exit()\n  } else {\n    node.alt = self.decode.raw(self.unescape(content), now) || null\n  }\n\n  return eat(subvalue)(node)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}